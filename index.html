<!DOCTYPE html>
<html>
<head>
    <title>Platformer</title>
    <style>
        canvas {
            border: none;
        }
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
            overflow: hidden;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <script>
        // Game setup
        const canvas = document.getElementById('gameCanvas');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        const ctx = canvas.getContext('2d');

        // Add window resize handler
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        // Game objects
        const player = {
            x: canvas.width * 0.1,
            y: canvas.height - 150,
            width: 30,
            height: 30,
            speed: 5,
            jumpForce: 12,
            gravity: 0.5,
            velocityY: 0,
            isJumping: false,
            jumpsAvailable: 2
        };

        let platforms = [
            { x: 0, y: canvas.height - 50, width: canvas.width, height: 50, timer: null, active: true, isGround: true, color: 'green' },
            { x: canvas.width * 0.4, y: canvas.height - 150, width: 200, height: 20, timer: null, active: true, color: 'green' },
            { x: canvas.width * 0.2, y: canvas.height - 250, width: 200, height: 20, timer: null, active: true, color: 'green' }
        ];

        const gameState = {
            score: 0,
            cameraPosY: 0,
            highestPlatformY: canvas.height - 250,
            gameOver: false
        };

        // Input handling
        const keys = {};
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            if (e.key === ' ') {
                e.preventDefault();
            }
        });
        document.addEventListener('keyup', (e) => keys[e.key] = false);

        function generatePlatform() {
            const minWidth = 100;
            const maxWidth = 200;
            const width = Math.random() * (maxWidth - minWidth) + minWidth;
            
            // Calculate maximum horizontal gap based on player's jump capability
            const maxHorizontalGap = (player.speed * 2) * (2 * player.jumpForce / player.gravity);
            
            // Get the highest platform's position
            const highestPlatform = platforms.reduce((highest, current) => 
                current.y < highest.y ? current : highest, platforms[0]);
            
            let x;
            // Ensure the new platform is reachable from nearby platforms
            if (highestPlatform) {
                const minX = Math.max(0, highestPlatform.x - maxHorizontalGap);
                const maxX = Math.min(canvas.width - width, highestPlatform.x + highestPlatform.width + maxHorizontalGap);
                x = Math.random() * (maxX - minX) + minX;
            } else {
                x = Math.random() * (canvas.width - width);
            }

            // Adjust vertical gap
            const minVerticalGap = 60; // Minimum gap between platforms
            const maxVerticalGap = 120; // Maximum gap between platforms
            
            // Generate new platform above the highest existing platform
            const y = highestPlatform ? 
                highestPlatform.y - minVerticalGap - Math.random() * (maxVerticalGap - minVerticalGap) :
                gameState.highestPlatformY - minVerticalGap;
            
            platforms.push({ 
                x, 
                y, 
                width, 
                height: 20, 
                timer: null, 
                active: true, 
                isGround: false,
                color: 'green'  // Initial color
            });
            gameState.highestPlatformY = Math.min(gameState.highestPlatformY, y);
        }

        function resetGame() {
            // Reset player position and state
            player.x = canvas.width * 0.1;
            player.y = canvas.height - 150;
            player.velocityY = 0;
            player.isJumping = false;
            player.jumpsAvailable = 2;  // Reset available jumps

            // Reset game state
            gameState.score = 0;
            gameState.cameraPosY = 0;
            gameState.highestPlatformY = canvas.height - 250;
            gameState.gameOver = false;

            // Reset platforms
            platforms.length = 0;
            platforms.push(
                { x: 0, y: canvas.height - 50, width: canvas.width, height: 50, timer: null, active: true, isGround: true, color: 'green' },
                { x: canvas.width * 0.4, y: canvas.height - 150, width: 200, height: 20, timer: null, active: true, color: 'green' },
                { x: canvas.width * 0.2, y: canvas.height - 250, width: 200, height: 20, timer: null, active: true, color: 'green' }
            );
        }

        // Game loop
        function gameLoop() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Check for game over
            if (gameState.gameOver) {
                // Draw game over screen
                ctx.fillStyle = 'black';
                ctx.font = '48px Arial';
                ctx.fillText('Game Over!', canvas.width/2 - 100, canvas.height/2);
                ctx.font = '24px Arial';
                ctx.fillText(`Final Score: ${gameState.score}`, canvas.width/2 - 70, canvas.height/2 + 40);
                ctx.fillText('Press Space to Restart', canvas.width/2 - 100, canvas.height/2 + 80);

                // Check for restart
                if (keys[' ']) {
                    resetGame();
                }

                requestAnimationFrame(gameLoop);
                return;
            }

            // Player movement
            if (keys['ArrowLeft']) player.x -= player.speed;
            if (keys['ArrowRight']) player.x += player.speed;
            if (keys[' '] || keys['ArrowUp']) {
                // Allow jumping if we have jumps available
                if (player.jumpsAvailable > 0) {
                    player.velocityY = -player.jumpForce;
                    player.jumpsAvailable--;
                    player.isJumping = true;
                }
                // Clear the key states to prevent holding for jumps
                keys[' '] = false;
                keys['ArrowUp'] = false;
            }

            // Apply gravity
            player.velocityY += player.gravity;
            player.y += player.velocityY;

            // Collision detection
            player.isJumping = true;
            for (const platform of platforms) {
                // Skip inactive platforms
                if (!platform.active) continue;

                if (player.x < platform.x + platform.width &&
                    player.x + player.width > platform.x &&
                    player.y + player.height > platform.y &&
                    player.y < platform.y + platform.height) {
                    
                    // Bottom collision (landing)
                    if (player.velocityY > 0 && 
                        player.y + player.height - player.velocityY <= platform.y) {
                        player.isJumping = false;
                        player.velocityY = 0;
                        player.y = platform.y - player.height;
                        player.jumpsAvailable = 2;

                        // Start disappearing timer if not already started and not ground
                        if (!platform.timer && !platform.isGround) {
                            platform.color = 'red';  // Change color immediately
                            platform.timer = setTimeout(() => {
                                platform.active = false;
                            }, 1000);
                        }
                    }
                    // Top collision (hitting head)
                    else if (player.velocityY < 0 && 
                        player.y - player.velocityY >= platform.y + platform.height) {
                        player.velocityY = 0;
                        player.y = platform.y + platform.height;
                    }
                    // Side collision
                    else {
                        if (player.x + player.width - player.speed <= platform.x) {
                            player.x = platform.x - player.width;
                        }
                        if (player.x + player.speed >= platform.x + platform.width) {
                            player.x = platform.x + platform.width;
                        }
                    }
                }
            }

            // Camera and platform management
            const cameraUpperBound = canvas.height * 0.4;  // Upper threshold
            const cameraLowerBound = canvas.height * 0.6;  // Lower threshold
            
            // Camera follows player up
            if (player.y < cameraUpperBound) {
                const cameraDelta = cameraUpperBound - player.y;
                gameState.cameraPosY += cameraDelta;
                player.y += cameraDelta;
                
                // Move all platforms down
                platforms.forEach(platform => {
                    platform.y += cameraDelta;
                });
            }
            // Camera follows player down
            else if (player.y > cameraLowerBound) {
                const cameraDelta = cameraLowerBound - player.y;
                gameState.cameraPosY += cameraDelta;
                player.y += cameraDelta;
                
                // Move all platforms up
                platforms.forEach(platform => {
                    platform.y += cameraDelta;
                });
            }
            
            // Platform management
            platforms = platforms.filter(platform => 
                platform.y < canvas.height + 100 && 
                platform.y > -100 && 
                (platform.active || platform.timer) // Keep platforms that are fading
            );
            
            // Generate new platforms if needed
            while (platforms.length < 8 || gameState.highestPlatformY > -canvas.height) {
                generatePlatform();
            }
            
            // Update score
            gameState.score = Math.max(gameState.score, 
                Math.floor(gameState.cameraPosY / 100));

            // Keep player in bounds
            if (player.x < 0) player.x = 0;
            if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;

            // Draw player
            ctx.fillStyle = 'red';
            ctx.fillRect(player.x, player.y, player.width, player.height);

            // Add score display before drawing platforms
            ctx.fillStyle = 'black';
            ctx.font = '20px Arial';
            ctx.fillText(`Score: ${gameState.score}`, 20, 30);

            // Draw platforms
            platforms.forEach(platform => {
                if (platform.active) {
                    ctx.fillStyle = platform.color;  // Use platform's color
                    ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                }
            });

            // Check if player has fallen too far
            const lowestPlatform = platforms.reduce((lowest, current) => 
                current.y > lowest.y ? current : lowest, platforms[0]);
            
            if (player.y > lowestPlatform.y + 200) {  // 200 pixels below lowest platform
                gameState.gameOver = true;
            }

            requestAnimationFrame(gameLoop); // coment a
        }

        // Start the game
        gameLoop();
    </script>
</body>
</html>
